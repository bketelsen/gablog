Remote Packages
With Go Get & Git
20 Jul 2013
Tags: golang,remote,packages,dependencies

Nathan Youngman

* Introduction

Go has an atypically strong suite of tools with go build, gofmt, godoc and gofix. For managing remote packages, we use `go`get`:

  go get github.com/howeyc/fsnotify

"One of the virtues of the Go tool is that it uses Git, Mercurial, Subversion, Bazaar..." - Andrew Gerrand, [[http://www.youtube.com/watch?v=p9VUCp98ay4][Go Fireside Chat 2013]]

Compared to a _traditional_ centralized repository, `go`get` has several advantages:

- easy to get started: use the DVCS we know
- name spaces for package names
- no additional processes or permissions to push a package
- encourages new developers to use version control
- a local copy of the full history, in case a remote repository disappears

* Embrace DVCS

As an extended example of _embracing_ the DVCS we know and love, lets consider forking a repository to add a feature or fix a bug (I'll be using Git).

- `go`get`-u`github.com/howeyc/fsnotify` for the latest changes (or just pull master)
- find and fix the bug, test it within our project, and commit the change to a feature branch
- fork the repository on GitHub to `github.com/mycompany/fsnotify`
- add a remote for the fork, push the change, and do a pull request

This all feels very natural. We didn't even need to tell our package manager to switch from using a nut/gem/egg to Git, and the repository was already cloned. Win!

What happens if our pull request goes unanswered for a few days?

- team members should go get the original repository to `src/github.com/howeyc/fsnotify`
- then add a remote for `github.com/mycompany/fsnotify`
- and checkout the feature branch for our bugfix

When the fix is merged upstream, everyone can checkout master and pull from the `origin` remote.

It's important to recognize that the Go compiler toolchain is only concerned with finding packages on disk. If your code imports `github.com/howeyc/fsnotify` then this package must be under `src/github.com/howeyc/fsnotify`. Any other third-party packages that import fsnotify will be looking there too. Lets consider this the _canonical_import_path_ for fsnotify.

It's best to avoid resorting to symlinks or rewriting imports if we don't need to.

* Reproducible Builds

"Version skew is a really, really bad problem." - Rob Pike, [[http://www.youtube.com/watch?v=bj9T2c2Xk_s][The path to Go 1]]

It's important for team members and CI servers to have a consistent view of the world. My first question for every reported issue is "are your dependencies up-to-date?"

The go tools don't provide a solution, what about Git? Git can store references to other repositories with [[http://git-scm.com/book/en/Git-Tools-Submodules][submodules]]. Submodules can work, but they aren't without [[http://git-scm.com/book/en/Git-Tools-Submodules#Issues-with-Submodules][issues]].

- it's possible for the main repository to reference unpushed changes in a submodule
- submodules are unaware of that fork we just made, so team members won't get our patch

Git also supports [[http://git-scm.com/book/en/Git-Tools-Subtree-Merging][subtree merging]] to store a remote repository within the parent. This improves the situation slightly.

- it's still quite tedious to check each dependency for updates
- limits us to working with Git, requiring mirrors for goamz, gocheck, mgo, etc.

This approach _divides_ the Go community by DVCS. Using mirrors makes it even more difficult to contribute across the DVCS boundary. This is a case where a simple tool could be better than relying on our DVCS.

* Virtual Environments

It can be helpful to separate dependencies by project, particularly if they depend on different revisions of the same dependency. The Go tools have _rudimentary_ support for this by modifying the GOPATH. A simple tool or shell script can switch the GOPATH for you.

To ensure that code completion and imports continue to work, editors must support [[https://github.com/DisposaBoy/GoSublime/blob/master/USAGE.md#per-project--settings--project-based-gopath][per-project settings]].

Third-party packages are like a black box in other ecosystems, but `go`get` has nothing to  hide. Exploring and contributing is easy and obvious, and thankfully the [[https://code.google.com/p/go/source/detail?r=7102e27d578ef3cdfd1dc1e2cf36f3a94e8fc226][issue with detached HEADs]] has been resolved.

* Versioning

Go get has no support for DVCS *tags*. Third-party tools can help, but until the Go community converges on one tool, it seems unreasonable to require a specific tool to install our package.

This has resulted in the makeshift solution of incorporating version numbers into the import path. If widely adopted, it follows that we will face builds with multiple versions of the same package.

As a relatively young ecosystem, not many packages have reached v2. A dependency resolver for [[http://semver.org/][semantic versions]] may be inevitable, but we still have some time to explore other avenues.

** Test-Driven Dependencies

When updating a package with [[http://kylelemons.net/blog/2012/04/22-rx-for-go-headaches.article][Rx]], it will run all the tests for the package and every package that depends on it. While this isn't nearly as fast as comparing a few version numbers, it provides greater assurances.

** Gofix Modules

While I love having `gofmt` reformat my code, I'm not yet accustomed to having a tool _alter_ my code, particularly when upgrading dependencies.

But given that we can easily review/revert the changes, gofix holds great promise for allowing API restructuring, particularly during the 0.x phase.

"not every change is gofixable, sometimes you need to understand the code" - Rob Pike, [[http://www.youtube.com/watch?v=bj9T2c2Xk_s][The path to Go 1]]

Fortunately, gofix can insert comments at the relevant locations:

  // TODO: Deprecated, use ....

How far can we take gofix? Can we make it easier for package authors to write and ship gofix modules?

** Curated Directory

The Go tool supports vanity import paths, which would allow a central curated directory of Go packages that are tested to work with one another.

** Code Analysis

[[http://semver.org/][Semantic versioning]] provides the prospective upgrader with three pieces of information:

- Major: Are the exported APIs different?
- Minor: Are there new features to evaluate?
- Patch: Does it only contain only bug fixes or security updates?

This information could be derived and aggregated from keywords in commit logs, standardized changelogs, issue trackers, and code analysis against exported identifiers. This isn't nearly as simple as a version number, but it can also provide richer information.

* Third-Party Tools

The Go Authors had the foresight to directly support DVCS in the Go tools. What `go`get` does not provide, we can build on top of this foundation.

"Everything else is built on this flexible foundation (FTP) and has grown over time." - Steffen Mueller, [[http://www.google.com/url?q=http%3A%2F%2Fmail.python.org%2Fpipermail%2Fdistutils-sig%2F2009-December%2F014977.html&sa=D&sntz=1&usg=AFQjCNHK-oYwAsIsjWXjqi44P8yDBIJgXQ][Python people want CPAN and how the latter came about]]

There are several package managers for Go, and so the _paradox_of_choice_. Diversity is good, to the extent that these tools explore different solutions. Yet it's hard to imagine multiple tools with different strategies not causing a fracture in Go community. Eventually we will need to _bless_ one particular strategy that meets our needs and makes our lives easier.

* Go Community

While we consider what tools we as a community wish to build and use, we should be mindful of how those tools will affect our community. I'm talking about trust, diversity, unity, joy, and sharing. These are as important as the technical solution itself.

In the course of researching for this article, I saw and experienced much confusion. I want to thank Dave Cheney and Kyle Lemons for helping me understand, and for many of the ideas presented here. I also would like to thank everyone who took the time to read & comment on the [[http://goo.gl/oqkvu][Go Packaging Google Doc]].

If you use Go, please take the time to share your thoughts by [[#][completing this survey]].


